#include "InstrProfile.hpp"

#include "types.hpp"

InstrProfile::InstrProfile(byte opcode) {
  code = opcode;
  bool error = false;
  used = false;
  type.args = vec<itype>(0);
  type.ret = vec<itype>(0);

  // The following switch should be autogenerated
  switch (opcode) {
#include "../opcode_switch.inc"
    default:
      name = "reserved";
  }
  // up to here
  if (!error) {
    has_args = (type.args.size() > 0);
  }
}

// Getters
instr_type InstrProfile::get_type() { return type; }
string InstrProfile::get_name() { return name; }
byte InstrProfile::get_code() { return code; }
bool InstrProfile::is_used() { return used; }
// Setters
void InstrProfile::use() { used = true; }

std::ostream &operator<<(std::ostream &os, const InstrProfile &i) {
  std::cout << i.name << "(0x" << std::hex << (int)(i.code) << std::dec << ")"
            << " :: " << i.type;
  return os;
}

ptype::ptype(u32 id, bool star, bool maybe)
    : id(id), star(star), maybe(maybe){};

std::ostream &operator<<(std::ostream &os, const instr_type &type) {
  // print the [
  os << "[ ";
  // print the args types
  for (auto const &type : type.args) {
    std::visit([&os](auto t) { os << t << " "; }, type);
  }
  // print the ] - > [
  os << "] â†’ [ ";
  // print the ret
  for (auto const &type : type.ret) {
    std::visit([&os](auto t) { os << t; }, type);
  }
  // print the  ]
  os << " ]";
  return os;
}
